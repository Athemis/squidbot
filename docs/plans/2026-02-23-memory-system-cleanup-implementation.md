# Memory System Cleanup — Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Fix three gaps after the global-memory redesign: stale SKILL.md, stale tool description, and unbounded session-summary growth.

**Architecture:** Task 1 is a pure doc edit (no code, no tests). Task 2 is a one-file cosmetic fix (no behaviour change, no test changes). Task 3 adds a trim guard inside `MemoryManager._consolidate()` with two new tests.

**Tech Stack:** Python 3.14, pytest, ruff, mypy.

**Design doc:** `docs/plans/2026-02-23-memory-system-cleanup-design.md`

**Prerequisite:** All 353 tests pass on `main`. Confirm: `uv run pytest -q`

---

### Task 1: Rewrite `squidbot/skills/memory/SKILL.md`

**Files:**
- Modify: `squidbot/skills/memory/SKILL.md`

No tests — this is agent-facing documentation only.

**Step 1: Replace the file**

Write the following content to `squidbot/skills/memory/SKILL.md`:

```markdown
---
name: memory
description: "Manage your long-term memory document across sessions."
always: false
requires: {}
---

# Memory Skill

## What you have

**`## Your Memory` (global MEMORY.md)** — Your personal, cross-session notes. Always
injected into your system prompt so you see it on every turn. You write to it using the
`memory_write` tool. Persists forever across all sessions.

**`## Session Summary`** — Auto-generated by the system when conversation history grows
long. Summarises earlier parts of this session so you can still reference them. You do
*not* write to this — the system manages it automatically.

## When to use `memory_write`

Use it **proactively** when you learn something that should persist to future sessions:

- User preferences ("prefers concise answers", "uses vim", "works in Berlin timezone")
- Ongoing projects ("building a Rust CLI tool called `ripdb`")
- Key facts about the user or their setup
- Things the user explicitly asks you to remember

Do **not** call `memory_write` for:
- Information relevant only to the current session
- Ephemeral task context ("we're currently debugging function X")
- Things already in MEMORY.md

## How to use `memory_write`

The tool **replaces** the entire MEMORY.md. Always:

1. Read the current `## Your Memory` section from the system prompt.
2. Merge new information in — do not lose existing facts.
3. Keep the document under ~300 words. Prefer bullet points over prose.
4. Write clean Markdown.

Example call:

```json
{
  "content": "## User Profile\n- Name: Alex\n- Works in Berlin (UTC+1)\n- Prefers concise, direct answers\n\n## Ongoing Projects\n- `ripdb` — Rust CLI debugger, repo at ~/git/ripdb\n"
}
```

## What NOT to do

- Do not write ephemeral session context to MEMORY.md (clutters future sessions).
- Do not let MEMORY.md grow unboundedly — trim stale facts when adding new ones.
- Do not confuse `## Your Memory` (your notes) with `## Session Summary` (system-generated).
```

**Step 2: Verify YAML frontmatter is intact**

Run: `head -6 squidbot/skills/memory/SKILL.md`

Expected output:
```
---
name: memory
description: "Manage your long-term memory document across sessions."
always: false
requires: {}
---
```

**Step 3: Run ruff (habit)**

Run: `uv run ruff check .`
Expected: no errors

**Step 4: Commit**

```bash
git add squidbot/skills/memory/SKILL.md
git commit -m "docs(skills): rewrite memory skill for two-level memory model"
```

---

### Task 2: Update `squidbot/adapters/tools/memory_write.py` description

**Files:**
- Modify: `squidbot/adapters/tools/memory_write.py`

No behaviour changes. No test changes needed.

**Step 1: Update the class docstring**

Replace the class docstring (lines 15–20 of the current file):

Old:
```python
    """
    Allows the agent to persist important information to its memory document.

    The memory document (memory.md) is injected into every system prompt,
    providing cross-session continuity for facts about the user's preferences,
    ongoing projects, and important context.
    """
```

New:
```python
    """
    Allows the agent to persist important information to its global memory document.

    The global memory document (MEMORY.md) is injected into every system prompt under
    '## Your Memory', providing cross-session continuity for facts about the user's
    preferences, ongoing projects, and important context.

    This tool REPLACES the entire document. Callers should merge existing content
    with new information before writing.
    """
```

**Step 2: Update the `description` attribute**

Replace:
```python
    description = (
        "Update your long-term memory document. Use this to persist important "
        "information that should be available in future conversations: user preferences, "
        "ongoing projects, key facts. The content REPLACES the current memory document."
    )
```

With:
```python
    description = (
        "Update your global long-term memory document (MEMORY.md). "
        "This document is visible in every future session under '## Your Memory'. "
        "Use this to persist: user preferences, ongoing projects, key facts. "
        "The content REPLACES the current document — always merge with existing content first. "
        "Keep the document under ~300 words."
    )
```

**Step 3: Run existing tool tests**

Run: `uv run pytest tests/adapters/tools/test_memory_write.py -v`
Expected: all PASS (no behaviour changed)

**Step 4: Run ruff + mypy**

```bash
uv run ruff check .
uv run mypy squidbot/
```
Expected: no errors

**Step 5: Commit**

```bash
git add squidbot/adapters/tools/memory_write.py
git commit -m "docs(tools): update memory_write description for global MEMORY.md model"
```

---

### Task 3: Cap session summary growth in `_consolidate()`

**Files:**
- Modify: `squidbot/core/memory.py`
- Modify: `tests/core/test_memory.py`

**Step 1: Write the two failing tests**

Add at the bottom of `tests/core/test_memory.py` (after the last existing test):

```python
# ---------------------------------------------------------------------------
# Summary cap: session summary trimmed when it grows too large
# ---------------------------------------------------------------------------


async def test_session_summary_capped_when_exceeding_word_limit():
    """Session summary is trimmed to the last 8 paragraphs when > 600 words."""
    # Build an existing summary that is already over the 600-word limit:
    # 10 paragraphs × ~82 words each ≈ 820 words
    fat_paragraph = "word " * 80
    existing_summary = "\n\n".join(
        f"Old paragraph {i}.\n{fat_paragraph}" for i in range(10)
    )

    storage = InMemoryStorage()
    await storage.save_session_summary("s1", existing_summary)
    llm = ScriptedLLM("New summary paragraph. " * 5)
    manager = MemoryManager(
        storage=storage,
        consolidation_threshold=3,
        keep_recent_ratio=0.34,
        llm=llm,
    )
    for i in range(4):
        await storage.append_message("s1", Message(role="user", content=f"msg {i}"))
    await manager.build_messages("s1", "sys", "new")

    saved = await storage.load_session_summary("s1")
    assert len(saved.split()) <= 600
    assert "New summary paragraph." in saved


async def test_session_summary_not_trimmed_when_under_word_limit():
    """Short summaries are stored verbatim — trimming is not applied."""
    storage = InMemoryStorage()
    await storage.save_session_summary("s1", "Short existing note.")
    llm = ScriptedLLM("Short new note.")
    manager = MemoryManager(
        storage=storage,
        consolidation_threshold=3,
        keep_recent_ratio=0.34,
        llm=llm,
    )
    for i in range(4):
        await storage.append_message("s1", Message(role="user", content=f"msg {i}"))
    await manager.build_messages("s1", "sys", "new")

    saved = await storage.load_session_summary("s1")
    assert "Short existing note." in saved
    assert "Short new note." in saved
```

**Step 2: Run tests to verify they fail**

Run: `uv run pytest tests/core/test_memory.py::test_session_summary_capped_when_exceeding_word_limit tests/core/test_memory.py::test_session_summary_not_trimmed_when_under_word_limit -v`

Expected: FAIL — no trimming logic exists yet.

**Step 3: Add constants and `_trim_summary()` helper to `squidbot/core/memory.py`**

After the `_CONSOLIDATION_SYSTEM` constant (around line 39), add:

```python
_SUMMARY_WORD_LIMIT = 600
_SUMMARY_KEEP_PARAGRAPHS = 8


def _trim_summary(text: str) -> str:
    """
    Trim a session summary if it exceeds the word limit.

    Keeps the last _SUMMARY_KEEP_PARAGRAPHS non-empty paragraphs so the most
    recent consolidation cycles are preserved. No-ops when within limits.

    Args:
        text: The full session summary text.

    Returns:
        The (possibly trimmed) summary text.
    """
    if len(text.split()) <= _SUMMARY_WORD_LIMIT:
        return text
    paragraphs = [p for p in text.split("\n\n") if p.strip()]
    return "\n\n".join(paragraphs[-_SUMMARY_KEEP_PARAGRAPHS:])
```

**Step 4: Wire `_trim_summary()` into `_consolidate()`**

In `_consolidate()`, find the lines that build `updated` (around line 219):

Old:
```python
        existing = await self._storage.load_session_summary(session_id)
        updated = f"{existing}\n\n{summary}" if existing.strip() else summary
        try:
            await self._storage.save_session_summary(session_id, updated)
```

New:
```python
        existing = await self._storage.load_session_summary(session_id)
        updated = f"{existing}\n\n{summary}" if existing.strip() else summary
        updated = _trim_summary(updated)
        try:
            await self._storage.save_session_summary(session_id, updated)
```

**Step 5: Run all memory tests**

Run: `uv run pytest tests/core/test_memory.py -v`
Expected: all PASS, including the two new tests.

**Step 6: Run full suite + lint + type-check**

```bash
uv run pytest -q
uv run ruff check .
uv run mypy squidbot/
```
Expected: all green, no errors.

**Step 7: Commit**

```bash
git add squidbot/core/memory.py tests/core/test_memory.py
git commit -m "fix(core): cap session summary growth to last 8 paragraphs at 600 words"
```
